Item 1 :
Static Methods instead of Constructor For creating object .
 
One advantage of static factory methods is that, unlike constructors, they
have names
A second advantage of static factory methods is that, unlike constructors,
they are not required to create a new object each time theyâ€™re invoked.
 
Classes that do this are said to be instance-controlled
 
a.equals(b) if and only if a==b
 
A third advantage of static factory methods is that, unlike constructors,
they can return an object of any sub type of their return type.
A fourth advantage of static factory methods is that they reduce the verbosity
of creating parameterized type instances
 
Disadvantages:
               The main disadvantage of providing only static factory methods is that
               classes without public or protected constructors cannot be subclassed.
               A second disadvantage of static factory methods is that they are not
               readily distinguishable from other static methods.
 
Item 2 :
Consider you have 10 properties of the object, out of this 10 properties 3 are required and other properties are optional. How will you design the class for this scenario.
               telescoping constructor pattern
                 JavaBeans Pattern  : not Thread safe
               Builder pattern : Preferred
the Builder pattern is a good choice when designing classes
whose constructors or static factories would have more than a handful of
parameters
 
 
Item 3 :
               a single-element enum type is the best way to implement a singleton  : Not Getting It
               Need to explorer more
Item 4:
               How to make sure that Class Cannot be instantiated
 
Item 5 : 
               avoid creating unnecessary objects. Baby boomer example
Item 6 :
               Eliminate obsolete reference
               When you do -- operation when you are executing the pop operation on stack.
               You should nullify the reference in pop operation
 
Item 7 : 
                 Avoid finalizer
 
Item 8 :
                 Obey General Contract when over riding Equals method
                               When to override Equals ?
                              
                              
                              
               Contract :  For non-null references for x y and others
					Reflexive: x.equals(x)== true
					Symmetric:x.equals(y)==y.equals(x)
					Transitive:For x,y,z x.equals(y)==y.equals(z)==x.equals(z)
					Consistent: multiple invocation of x.equals(y) will give the same result if x and y are not 	     changed.                             
                     x.equals(null)==false	         
                              
               Performance Optimization:
                              
                              
                              
                              
                              
                              
                              
Item 9 :
                              Always override the hashcode method if you have overriden equals .
               Contract :
                              
                              
                              
               
                              How to convert the hashtable to linked list  ?
                              
                              
                              You must exclude any fields that are not used in equals comparisons.        
                              Do not be tempted to exclude significant parts of an object from the hash
                              code computation to improve performance.
 
Item 10 :
                              Always override toString
                              
                              
 
Item 11 :
                              OverRide Clone Judiciously
                               
 
Item 13 :
                              Minimize the accessibility of classes and members
                              Encapsulate as much as possible .
 
Item 14 :
                              In public classes, use accessor methods, not public fields
                              
                               
 
Item 15 :
                              Minimize mutability :
                              Always make immutable class, make class mutable only if its you want to change the state of object.
 
Item 16 :
                              Composition vs Inheritance 
                              If you are using Inheritance just for code reuse.
                              Think again         because its a overhead. It will add all the methods which you don`t want use .
                              
                              If you are using Inheritance to maintain type hierarchy then its great.
                              
                              Composition and Inheritance both are getting used in CDI .
                              
                              when you use @Inject on variable Container will inject the instance of that particular class in variable . That injection is composition.
                              
                              Which one to inject is based on inheritance
                              
 
Item 17 : 
                              Design and Document for inheritance or else prohibit it .
 
Item 18 :                             
                              Prefer interfaces to abstract classes .
                              
                              But never release half cooked interface , because if Client starts using it you cannot change it .
                              
Item 19 : 
                              Use interfaces only to define types
                              Never use the interface for Constants .
 
Item 20 : Prefer Class Hierarchy /Inheritance to tagged class .
 
Item 21 : Use function object to represent Strategies 
                                Comparator Interface and compare method .
                                Comparator object acts as function object.
                              
Item 22 :
What is difference between the Static nested class and non static nested class ?
When to use static nested class and non static nested class ?
                               
                               
                              public class Hash {
                              public int h=10;
                              private  void length() {
                              System.out.println("Hash:
               }
               public Entry getEntry(){
                              return new Entry();
               }
               
               public class Entry{
                              
                              
                              }
                              public Hash getHash(){
                              return null;
                              }
               }
               
                              
 
                               
                              main(){
                              
                              Hash.Entry ent=hash.new Entry();  // ent will contain instance of Hash . Means if you call the methods of                                                                  hash                               
                              }
 

Item 23  : 
    Don`t use raw type , Always use generics while writing code . Collection still supports it for backward compatibility .

Item 24  : 
	While Writing generic code you will get lots of errors and warnings . Eliminate all warnings before you push your code into production.

Item 25 :
	Prefer Lists 

Item 26 :
Item 27 :
	Prefer generic types and Generic methods

Item 28 : 
	Use Bounded wild cards ;

	Take a look at following example

	 		public class Animal {}
	 		public class Human extends Animal{}
	 		public class Dog extends Animal {}

	 		// Written as part of sdk
	 		public interface AnimalOps {
			public void addElements(List< ? super Animal> list);
			public void processElements(List< ? extends Animal> list);
			}

			//Written by the team who is using your sdk 
			public class DogOps implements AnimalOps {

			@Override
			public void addElements(List<? super Animal> list) {
				
				//Error can`t retrive only adding is possible 
				for(Animal a: list){
				}
			}

			@Override
			public void processElements(List<? extends Animal> list) {

				// can`t add only retival is possible.
				list.add(new Human());
						
			}

	
}
Item 30 :

	Use enums instead of int Enum pattern or String enum patterns
	Why ? Because you can impose restriction on client to only accept one of the enum types.

	You use enum as singleton class
	you can add methods to the enum
	you can have constructor in enum but its not accessible outside of enum. means you can access the public methods of enum by using enum constants.
	Use enum on left side when comparing 

Item 31 :

	Never Ever ever use the int number (ordinal) associated with Enum constants .
	Maintainance Nightmare , If you want to add new constant in between the exsisting constants. Or by mistake you change the arrangement of Constants the int value associated with it will change .
	Instead pass the int value as a parameter to Enum constant and set it as a instance field.

	Then use that instance Field . Don`t make instance field public insted write public accessors getter methods. 
	You can`t write setter method as Enums are immuatable. Its best prcactise to make all the enum instance fileds final.
	

Item 32 :
	Use EnumSet instead of bit fields.

	Bit fileds are used to combine several options in one int number.
	All options are int constants 
	Bit manipulation is done to set combination of needed options.

	Use Enumset insted. Enumset is create using Enum of particular Enum type with or without enum constants.

	EnumSet have static method by which you can create instance of EnumSet.

	EnumSet<EnumType> set= EnumSet.of("EnumType".ENUMCONSTAT1,"EnumType".ENUMCONSTAT2);

	You can iterate over this set.Iterator iterates over the enum in order of decleration of enum constants.

	Bit vector is used to store the Enum constants.

	EnumSet is abstract class . The implemation is packge private : RegularEnumSet (For 64 enumconstants), JumboEnumSet (more than 64)
	
	You can create Enumset of same Enum type adding other type of enum constant will give comple time error .
	
Item 33 :EnumMap
	  you can only use enum constants as a key in EnumMap
	  Cannot use null as a key
	  Iterator behaves same as EnumSet .
	  Iterators are weakly consistent, will never throw ConcurrentModificationException 

Item 34 : Enum implement another interface
Item 35 : Prefer annotation to namming patterns
Item 36 : Consistently use Override annotation . 
	  This will help when you thought you have overridden a method from parent class but actually you have overloaded it .
	  
	  class Animal{
	  @Override
	  public boolean equals(Animal a){      // will give compile time error
	  
	  }
	  }
Item 37 :
	  Use marker interface to define type .
	  Marker annotaion and marker interface have diffrent usage
	  If you are using marker interface use it to define type.
	  If you want to interfere some meaning out of the class use marking annotaion because later you can add attributes to annotaion .
	  
	  
	  

	

